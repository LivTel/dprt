\documentclass[10pt,a4paper]{article}
\pagestyle{plain}
\textwidth 16cm
\textheight 21cm
\oddsidemargin -0.5cm
\topmargin 0cm

\title{Data Pipeline Real Time Module}
\author{C. J. Mottram}
\date{}
\begin{document}
\pagenumbering{arabic}
\thispagestyle{empty}
\maketitle
\begin{abstract}
This document gives an overview of the Data Pipeline Real Time reduction module. It describes the directory structure,
how the program is organised, how the program is built and the environment needed to build it. It gives an overview
of how the system communicates with the CCS. It does not discuss the actual data reduction itself.
\end{abstract}

\centerline{\Large History}
\begin{center}
\begin{tabular}{|l|l|l|p{15em}|}
\hline
{\bf Version} & {\bf Author} & {\bf Date} & {\bf Notes} \\
\hline
0.1 &              C. J. Mottram & 1/7/99 & First draft \\
\hline
\end{tabular}
\end{center}

\newpage
\tableofcontents
\listoffigures
\listoftables
\newpage

\section{Introduction}
This document describes the first prototype version of the DpRt, the Data Pipeline Real Time module. This process
takes FITS images generated by the camera process (the CCS) and reduces them. This involves processing the data
in the image against various calibration images. The processing is done in two stages, a  real time
module and an off-line module. This process deals with the real time part of the processing. 
Two documents that describe this process in more detail are \cite{bib:ltpf} and \cite{bib:drpl}.

\section{Program Structure}
A basic overview of the program structure is given in Figure \ref{fig:dprtprogstruct}.

\setlength{\unitlength}{1in}
\begin{figure}[!h]
	\begin{center}
		\begin{picture}(3.5,3.5)(0.0,0.0)
			\put(0,0){\special{psfile=dprt_program_structure.eps   hscale=65 vscale=65}}
		\end{picture}
	\end{center}
	\caption{\em DpRt Program Structure.}
	\label{fig:dprtprogstruct} 
\end{figure}

As Java is used to implement most of the program, each part of the program is represented by a Java Class. 
The actual processing of the Data is done by the C routines in the C Library API. Some C in the library is `glue'
between the C library API and native Java methods in the Java Library Interface. The `glue' does things like
copy Java parameters to C parameters.

To further understand why the program is divided into objects in this manner, it is necessary to understand how
the program fulfills the functionality needed by looking at how the program executes.

\subsection{Execution of the program}
The DpRt program executes like a typical server program, that receives requests from a client,
does some processing and returns some data to the client process. The client in this case is the CCS process,
which sends FITS exposures to the DpRt for processing.

A diagram that tries to show the execution of the process is shown in Figure \ref{fig:dprtexecution}.

\setlength{\unitlength}{1in}
\begin{figure}[!h]
	\begin{center}
		\begin{picture}(3.5,3.5)(0.0,0.0)
			\put(0,0){\special{psfile=dprt_execution.eps   hscale=65 vscale=65}}
		\end{picture}
	\end{center}
	\caption{\em DpRt Execution Model.}
	\label{fig:dprtexecution} 
\end{figure}

The program is multi-threaded. This allows it to wait for a second connection from a client whilst the
first command sent by the client is being processed. This allows DpRt to recognize an Abort message whilst
some data is being reduced and stop what it is doing.

\subsubsection{DpRt Main Program}
The main routine in the DpRt program starts by initialing various modules in the program. This includes the status 
class that maintains the state of the process (what it is currently doing). It loads the properties in the
properties file. A server thread is started to deal with connections made from clients. The main thread then waits
for the server thread to stop. Currently this never happens, but it will probably eventually occur when the 
process needs to terminate (i.e. to reboot or similar).

\subsubsection{DpRt Server Thread}
This creates a Socket Server and then enters an infinite loop. It waits for a connection to be made to the server,
and then starts a thread to deal with this connection. This allows more than one connection to dealt with 
at once.

\subsubsection{DpRt Connection Thread}
This handles one particular connection made to the DpRt program. An object of this class is instantiated for
each connection made to the server. It goes through the standard JMS protocol, calculating an Acknowledge time and
sending an acknowledge message, processing the command and then returning a Done message. Before processing the
command, it ensures that another reduction process is not already underway by checking the current
status of the process. Whilst processing is underway the status object keeps track of the thread doing the 
processing.

\subsubsection{DpRt Library Java Interface}
This object controls the interface to the C library that actually performs the reduction. For each public
Java routine to call, there is a corresponding private native Java routine, that when called, makes a call
into the C library. At initialisation time this object loads the shared C library. 

\subsubsection{DpRt Library JNI C glue}
For each native routine in the DpRt Library Java Interface, there is a corresponding C routine that gets called when
the Java method is called. They have a strange naming convention so that the Java runtime knows how to map
native routines to them successfully. These routines convert the Java parameters into `proper' C parameters, call
the actual C API routine, and then put any return parameters back into a Java object to return to the Java.

\subsection{Java Class Structure}
The Java class structure contains the following classes.

\subsubsection{DpRt}
This is the `main' class, that contains a {\em main} routine (as in C) that is called when the program is started.

The {\em init} routine initialises the DpRtStatus and DpRtLibrary objects. It makes the DpRtStatus object
load it's properties from the {\em dprt.properties} file, and initialises various parameters from the properties.

The {\em parseArgs} routine parses any command line arguments passed into the program, that can override some
of the loaded properties values.

The {\em run} method creates the DpRtTCPServer object, starts it (it is a thread) and waits for it to terminate.

\subsubsection{DpRtConstants}
The DpRtConstants class holds a series of constant values for the DpRt program. An object of this class is never
instantiated, all the values are class variables. Most of the constants are error codes.

\subsubsection{DpRtLibrary}
This class contains the Java API for the routines that actually reduce the data. 
There is one instance of this class in the program. For each public method this
class contains, there is a corresponding private native routine that is called. The routines that are native 
get converted by the Java runtime into C library calls into the {\em libdprt} library, 
that is loaded in a static code block in this class.

\subsubsection{DpRtStatus}
This class holds the current status of the DpRt program. There is one instance of this class in the program.
When the program spawns a thread to deal with a 
reduction request, it is stored in the instance of this class. This allows us to check whether the 
program is already reducing a FITS file when a reduction request comes in.

This class also holds a property list, loaded from the {\em dprt.properties} file, that holds various
constants that the program might need. These can be accessed using the access methods in this class.
There are several access methods to return the properties (which are always strings) as various different
types.

\subsubsection{DpRtTCPServer}
This is the class that sits on a port awaiting connections. It is a thread class, and one instance of this
class is created and started by the main program. If we look at the source code, we cannot see a lot
of implementation. This is because this class extends (is a sub-class of) the {\em TCPServer} class, which is
the standard JMS class for dealing with connections to the server \cite{bib:jmsnnp}. 
The {\em TCPServer} class implementation
can be seen in the {\em ngat/net/TCPServer.java} file, where it can be seen that this class extends
java.lang.Thread, the standard Java thread class. This means that when {\em server.start()} is called in
the DpRt class, {\em TCPServer}s {\em run} method is called, which creates a SocketServer and awaits for
connections. 

When the {\em TCPServer} class {\em accept}s a connection, it calls {\em startConnectionThread} to start
a thread to deal with the connection. Because we have overridden the {\em startConnectionThread} method in
the {\em DpRtTCPServer} class, this method will get called over {\em TCPServer}s {\em startConnectionThread} method.
This enables the {\em DpRtTCPServer} class to start it's own {\em DpRtTCPServerConnectionThread} and to set
the thread DpRt reference and error stream reference.

\subsubsection{DpRtTCPServerConnectionThread}
An instance of this thread class is constructed for every connection the {\em DpRtTCPServer} class makes.
The thread implements the JMS protocol for sending and receiving messages from processes. This class 
inherits most of the standard JMS functionality from the {\em TCPServerConnectionThread} super-class
(in {\em ngat/net/TCPServerConnectionThread.java}, which
contains the {\em run} method which is called when the thread is started \cite{bib:jmsnnp}.

The {\em DpRtTCPServerConnectionThread}
overrides the {\em calculateAcknowledgeTime} and {\em processCommand} methods, which calculate how
long operations are going to take and calls the relevant C API routines (via the instance of the 
DpRtLibrary class) to do the reduction. This class also uses the {\em abortProcessCommand} field to try
to stop an executing thread when an ABORT message is received.

\subsection{C Library Structure}
The C library contains the actual data reduction routines. It also contains the Java JNI interface glue that the 
Java Native routines call to link to the C library.

\subsubsection{DpRtLibrary}
This the module that implements the native methods in the {\em DpRtLibrary} class. The header file for this 
module (in the {\em include} directory) is machine generated using the {\em javah} command on the class file. 
The module calls various JNI C routines (defined in the {\em \verb'<'jni.h\verb'>'} header file) to transfer the Java method
parameters into C type equivalents. The relevant C API routine (defined in {\em ``dprt.h''}) is called to
do the reduction, and the results from this call are put into the DONE object. 

Note there are problems compiling this module with the ANSI C compiler flags set. This is because the Java
header file {\em \verb'<'jni.h\verb'>'} does not conform to ANSI C.

\subsubsection{dprt}
This is the top level file with the C API for the data reduction routines in it. The external function
prototypes are declared in the header file (in the {\em include} directory) and the code is actually in the
{\em c} directory. 

There are two routine for reduction at the moment, one for calibration images and one for
exposure images, which return different parameters. These routines are largely unimplemented at the moment.

The return filename needs to be allocated, this enables
it to be any length. During processing the abort flag must be regularly checked to ensure another thread
has no received an ABORT message and wants this reduction to stop.

If an error occurs during the execution of a reduction, the {\em DpRt\_Error\_Number} and {\em DpRt\_Error\_String}
should be filled with suitable values to indicate the cause of the problem. These values are picked up
by the Java layer for the DONE message. If a reduction fails the routine should return FALSE to
set the DONE objects successful flag to FALSE.

\section{Directory Structure}
The current prototype is located in the {\em dprt} directory. This should be installed from the 
{\em dprt.tar.Z} archive under a home directory. On {\em ltobs5} it is installed in the {\em /home/dev}
directory and on {\em ltccd1} it is installed in the {\em /space/home/cjm} directory. Currently the version
on {\em ltobs5} is the current master copy, and is the one that should be edited. The master copy will
be moved to {\em ltccd1} when this machine has been setup for development.

The current directory structure is displayed in Figure \ref{fig:dprtdir}.

\setlength{\unitlength}{1in}
\begin{figure}[!h]
	\begin{center}
		\begin{picture}(5.0,6.5)(0.0,0.0)
			\put(0,0){\special{psfile=dprt_dirtree.eps   hscale=65 vscale=65}}
		\end{picture}
	\end{center}
	\caption{\em DpRt Directory Structure.}
	\label{fig:dprtdir} 
\end{figure}

\subsection{Top Level Contents}
\begin{itemize}
\item {\bf c} This contains the C library source code to build {\em libdprt}, the C library that actually does the
data reduction. The Java class {\em DpRtLibrary} picks up the shared version of this library to do the reduction.
The test program {\em dprt\_test} picks up the static version of this library to test the library.
\item {\bf include} This contains the C library headers that declare the external routines in {\em libdprt}.
\item {\bf java} This contains the Java sources for the classes that make up {\em DpRt}, the Java server that 
receives messages from the CCS and passes FITS filenames in them to {\em libdprt} for data reduction.
\item {\bf test} Contains the C code to build {\em dprt\_test}, a C test program to test data reduction in 
{\em libdprt} without using the Java wrappers.
\item {\bf latex} Contains \LaTeX documentation for dprt deliverables.
\item {\bf javadocs} Contains generated API documentation for the Java classes in the {\em java} directory. The 
documentation is generated using the {\em javadoc} tool when the {\em java} directory is built.
\item {\bf Makefile} The top-level Makefile for the dprt directory. Can be used for building all the
deliverables in this directory, for checking in  and out the source code in each directory, and for creating a 
backup tar file. Most targets are achieved by calling Makefiles in each of the sub-directories that contain code.
\item {\bf backup.csh} Shell script that backs up the contents of this directory into a suitable tar archive.
This mechanism of backing up is being replaced, type {\em make backup} in the {\em dprt} directory instead.
\footnotemark
\item {\bf cdocs} The generated API documentation from the {\em c} directory is put into this directory. The
documentation is generated when {\em libdprt} is built using the {\em cdoc} tool.
\item {\bf README} Text file reminding us what is contained in this directory.
\end{itemize}
\footnotetext{Note to use this script the CHECK\_IN\_MESSAGE environment variable must be set to a message string to check the source in with.}

\section{Editing, Compiling and Running DpRt}
\subsection{Environment}
Several environment variables/alias need to be setup in the shell being used for compilation/running the
DpRt to enable all the libraries/tools to be found.

The Makefiles are run using the {\em make} command. Some environment variables need to be defined to specify
system specific options before running the makefiles. These are defined in the {\em lt\_environment.csh}
shell script in the top level directory. This needs to be sourced before the programs/libraries can be built.
The script is different on each system the software can be compiled on.

The important environment variables that are defined are listed in Table \ref{tab:makeenv}.

\begin{table}[!h]
\begin{center}
\begin{footnotesize}
\begin{tabular}{|l|p{40em}|} \hline
{\bf Variable} 	& {\bf Description} \\ \hline
LT\_HOME	& Top level directory the sources are installed under. \\ \hline
JAVA\_HOME	& Home directory of Java class libraries/executables. \\ \hline
CCSHAREDFLAG	& C Compiler flag to build a shared C Library. \\ \hline
JNIINCDIR	& Location of Java JNI headers. \\ \hline
JNIMDINCDIR	& Location of Java JNI machine dependent headers. \\ \hline
CCHECKFLAG	& C Compiler flags for ANSI C compliance and extra warnings \footnotemark. \\ \hline
TIMELIB		& Library to link against to get POSIX nanosleep functionality. \\ \hline
CDOC\_HOME	& Home directory of the {\em cdoc} C source documentation tool. \\ \hline
CLASSPATH	& Directories and Jar files to look for Java classes in. 
{\em ngat\_net\_util.jar} contains the JMS network library classes. 
{\em message\_*.jar} contains the JMS message classes. 
{\em djgl\_2\_0\_svid.jar} contains the JDK1.1.x/JDK1.2.x compatible version of the djgl collection classes. 
{\em pse.zip},{\em tools.zip} and {\em classes.zip} contain the Object-Store database classes.  \\ \hline
LD\_LIBRARY\_PATH & Path for Java to search for shared libraries in.  \\ \hline
\end{tabular}
\end{footnotesize}
\end{center}
\caption{\em Table of Environment variables for the makefiles.}
\label{tab:makeenv} 
\end{table}
\footnotetext{Extra checking is switched on using the {\em checkon} command and off using
the {\em checkoff} command. It is on by default.}

The {\em PATH} environment variable needs to include all paths to the executables needed to build/run the 
programs. This includes the java directories, RCS executables(co,ci and rcs), cc,lint,yacc,lex and others.

\subsection{Makefile hierarchy}
Makefiles are used by the {\em make} tool to build projects from source code to their final executable form.
Type {\em man make} to read the documentation on {\em make}.
There are several Makefiles in the dprt directory that are used to build parts of the program. These
are documented in Table \ref{tab:makefile}.

\begin{table}[!h]
\begin{center}
\begin{footnotesize}
\begin{tabular}{|l|p{20em}|p{20em}|} \hline
{\bf Location} 		& {\bf Description} 				& {\bf Targets supported} \\ \hline
\verb'~'/Makefile	& Builds all the targets in the sub-directories. & 
top, checkin, checkout, clean, tidy, backup \\ \hline
\verb'~'/Makefile.common& Common makefile included in all Makefiles to give common definitions and location of tools &
None (don't call this Makefile, it is included in other Makefiles). \\ \hline
\verb'~'/dprt/Makefile	& Top-level dprt Makefile, calls makefiles in java,c and test directories to build targets &
top, checkin, checkout, clean, tidy, backup \\ \hline
\verb'~'/dprt/c/Makefile& Makefile for libdprt c library, includes checkin/checkout for the headers in the 
include directory &
top, static, staticdepend, depend, lint, checkin, checkout, clean, tidy \footnotemark[3] \\ \hline
\verb'~'/dprt/java/Makefile& Makefile for the Java classes in the DpRt program. &
top, checkin, checkout, clean, tidy \footnotemark[4] \\ \hline
\verb'~'/dprt/test/Makefile& Makes the test programs &
top, depend, clean, checkin, checkout\\ \hline
\end{tabular}
\end{footnotesize}
\end{center}
\caption{\em Table of Makefiles.}
\label{tab:makefile} 
\end{table}
\footnotetext[3]{The {\em top} target only builds the shared library by default, use {\em make static} to build
a statically linked library.}
\footnotetext[4]{The {\em top} target also creates the machine generated header file 
{\em ~/dprt/include/DpRtLibrary.h}, using the {\em javah} tool on the {\em DpRtLibrary.java} file.}

\subsubsection{Common Makefile Targets}
When {\em make} is invoked, it searches for a {\em Makefile} in the current directory. If one is found, it
will try and produce a specified target. If a parameter is passed to make it will try and build that target
(e.g. {\em make checkout} will try to produce the `checkout' target). If no parameter is passed {\em make} will
try to produce the first target in the Makefile.
Some makefile targets are common across most of the makefiles in the project. The meaning of these targets is
shown in Table \ref{tab:maketarget}.

\begin{table}[!h]
\begin{center}
\begin{footnotesize}
\begin{tabular}{|l|p{40em}|} \hline
{\bf Target Name} 	& {\bf Description}\\ \hline
top			& This is always the first target in a Makefile, which is the one that gets built 
when {\em make } is called with no parameters. It builds the executable, library or class files from the 
sources.\\ \hline
checkin			& This target `checks in' the source files in the directory into RCS. This keeps
track of versions of source codes. See {\em man ci} for more details.  \\ \hline
checkout		& This target `checks out' the source files from the RCS directory. The source files
should be checked out for building or editing. See {\em man co} for more details. \\ \hline
clean			& This target cleans the directory of results of compilations, such as object files and
executables. It also `tidies' the directory by deleting backup files. 
See {\em TIDY\_OPTIONS} in the {\em Makefile.common} file. \\ \hline
tidy			& This target deletes backup files. See {\em TIDY\_OPTIONS}
in the {\em Makefile.common} file.\\ \hline
backup			& This target creates a compressed tar in the top level directory of the contents of the dprt
directory. It first tidies all the directories and also cleans directories with executables that are not
machine independent (i.e. cleans C executables but not Java classes).\\ \hline
static			& This target only applies to libraries, and builds a statically linked library 
(e.g. libdprt.a) rather than a shared library (e.g. libdprt.so). Shared libraries are loaded by Java
classes, static libraries can be linked against C test programs.\\ \hline
depend			& This target only applies to C source code. It calls {\em makedepend} to get the
list of dependent header files for each source file and appends this to the Makefile. This allows {\em make}
to know what objects need to be re-built when a header file is changed.  The Makefile should be
writable but should not be edited whilst this target is run.\\ \hline
lint			& This target only applies to C source code. {\em lint} is a tool that examines the
C source code for common programming problems and displays the results.\\ \hline
\end{tabular}
\end{footnotesize}
\end{center}
\caption{\em Table of common Makefiles Targets.}
\label{tab:maketarget} 
\end{table}

\subsection{Editing/RCS}
Editing the source files is accomplished using any text editor, much as most text files are edited. Before 
editing, however, the source files need to be `checked out' of the Revision Control System RCS. The relevant sources
need to be locked during checkout so that other uses cannot edit them. This is achieved by typing
{\em co -l \verb'<'source filenames\verb'>'}. Sometimes {\em co} will ask questions if sources are already checked out as being
writable. This probably means someone else is working on the source files.

After the sources have finished being edited, they should be checked back in using {\em ci \verb'<'source filenames\verb'>'}. This
will ask you for a log message for each file to describe the changes made to it.

It is worth reading the {\em rcsintro} man page to get more information on RCS.

\subsection{Compilation}
The relevant environment must have been sourced in the {\em lt\_environment.csh} shell. The sources must have been
`checked out' from the RCS before compilation can take place. The sources do not have to be locked, i.e. they can
be checked out using {\em co \verb'<'source filenames\verb'>'} or {\em make checkout}.

To build the executables/classes in a particular directory, just type {\em make} or {\em make top}. 
This will execute the commands
to build the `top' target in the current directory. You should end up with an executable, a library or a series
of class files. Note in the case of the shared library {\em libdprt.so}, this is placed in the java directory
ready to be loaded by the Java class {\em DpRtLibrary}.

\subsection{Running}
The dprt directory contains two executables that can be run. One is the {\em dprt\_test} C program, that just
tests the C API. The other if DpRt, a Java class that starts up a server waiting for client connections.

\subsubsection{dprt\_test}
This executable is in the dprt/test directory. It is run by just typing {\em dprt\_test} in this directory.
Specifying no parameters or typing {\em dprt\_test -help} gives the parameter information reproduced below:
\begin{verbatim}
dprt_test [-c] [-e] [-help] <filename>
-c reduces the filename as a calibration image.
-e reduces the filename as a expose image.
-help prints this help message and exits.
You must always specify a filename to reduce.
\end{verbatim}
To test the data reduction routine you will need a FITS file to test them on.

\subsubsection{DpRt}
This is a Java server program. If it is run by typing {\em java DpRt -help} it prints the following help message
and then exits.
\begin{verbatim}
DpRt Help:
DpRt is the 'Data Pipeline', which process FITS files passed to it.
Options are:
        -s[erverport] <port number> - Port to wait for client connections on.
        -l[og] <log level> - log level.
        -t[hreadmonitor] - show thread monitor.
\end{verbatim}

To start the server and leave it running, ready to receive client connections, type the following:
{\em java DpRt -l 2\&}. The server port number can be specified on the command line, if it is not it is
picked up from the {\em dprt.properties} file in the dprt/java directory. This also specifies the log and
error file to put log and error messages respectively.

You then need to run the client program to call the DpRt server. Currently the CCS is the only program that
calls the DpRt for data processing, there will be a SendCCSCommandFile in the test directory that will
impersonate the CCS eventually (as per the SendISSCommandFile program in the ccs/test directory \cite{bib:ccs}).

\section{Conventions/Abbreviations}
\begin{center}
\begin{tabular}{|l|l|p{25em}|}
\hline
{\bf Abbreviation} & {\bf Full Name} & {\bf Description} \\
\hline
CCS  & CCD Control System      		& The process that controls the SDSU CCD Controller. \\
DpRt & Data Pipeline Real Time 		& The process that does real-time reduction of the FITS image data. \\
FITS & Flexible Image Transport System 	& The standard file format for astronomical images. \\
JMS  & Java Message System     		& The protocol used to communicate between Java processes in our system. \\
JNI  & Java Native Interface   		& The mechanism used by Java to call native (i.e. C) code from within Java. For
details on how this works see \cite{bib:jnitut}. \\
RCS  & Revision Control System		& A suite of tools used to keep track of versioning of source files, and
ensuring only one person can edit a source file at a time. Type {\em man rcsintro} for more details. \\
\hline
\end{tabular}
\end{center}

\begin{thebibliography}{99}
\addcontentsline{toc}{section}{Bibliography}
\bibitem{bib:ltpf}{\bf Liverpool Telescope Pipeline Flow}
Lee Howells.
\bibitem{bib:drpl}{\bf Data Reduction Pipe-Line}
Lee Howells.
\bibitem{bib:jnitut}{\bf Java Native Interface}
Sun Microsystems 
{\em http://java.sun.com/docs/books/tutorial/native1.1/index.html}
\bibitem{bib:jmsnnp}{\bf Java Message System: ngat.net package}
C. J. Mottram {\em http://150.204.240.95/devngatlatex/ngat.net.dvi}
\bibitem{bib:ccs}{\bf CCD Control System First Prototype}
C. J. Mottram {\em http://150.204.240.95/devccslatex/ccs.dvi}
\end{thebibliography}
\end{document}
